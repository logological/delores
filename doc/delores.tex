% $Id: delores.tex,v 1.2 2003-12-14 14:47:34 psy Exp $
\documentclass[a4paper,10pt,twocolumn]{article}
\usepackage{url}
\usepackage{fullpage}

\begin{document}
\title{DELORES Programmer's Guide}
\author{Tristan Miller\\
\url{Tristan.Miller@dfki.de}}
\date{13 December 2003}
\maketitle
\tableofcontents

\section{Introduction}
\subsection{About this document}

DELORES is a defeasible logic interpreter which works in interactive
or batch mode. The following document is intended to assist future
developers and maintainers of the DELORES project in comprehending the
structure of the source code. It is not intended to cover in great
detail the inner workings of the individual functions, and as such
should not be considered a replacement for the program's internal
documentation.

\subsection{Program history}

The original DELORES was implemented from 13 October 1999 to 13
January 2000 at Griffith University by Tristan Miller, based on
instructions and papers provided by Michael Maher. The system was
revised for public release in December 2003 by Tristan Miller, then at
the German Research Center for Artificial Intelligence (DFKI GmbH) in
Kaisers\-lautern.

\section{Overview of project files}

Files in the DELORES distribution are organized into a number of
subdirectories.  \texttt{doc} contains the program documentation,
\texttt{src} contains the program source, \texttt{examples} contains
sample theories for DELORES, and the root directory contains various
files related to project management.

\subsection{Project management}

The DELORES project is distributed using the GNU Build System; the
distributed files therefore adhere more or less to the GNU coding
standards.

\subsection{Metadata files}

The files \texttt{AUTHORS}, \texttt{ChangeLog}, \texttt{COPYING},
\texttt{INSTALL}, \texttt{README}, \texttt{NEWS}, and \texttt{THANKS}
are all required by the GNU Build System.  They are self-explanatory
and should be manually updated when any major changes are made.  As
DELORES is maintained in a CVS repository, it is easiest to update the
\texttt{ChangeLog} file with the GNU \texttt{rcs2log} program.

The \texttt{BUGS} and \texttt{TODO} files are not mandated by the GNU
standards but are included for obvious reasons.

\subsection{Build files}

The human-created files for use with Autoconf and Automake are
\texttt{configure.ac} and \texttt{Automake.am}.\footnote{Each
  subdirectory in the distribution may have its own
  \texttt{Automake.am}.}  Refer to the GNU Autoconf and Automake
manuals for how to edit these files.

Every other file included in the distribution and not mentioned in
this manual is automatically produced by the GNU Build System.

\subsection{Documentation}

\subsubsection{\texttt{delores.1}}

This is the Unix man page for DELORES, written with \texttt{troff}
macros.

\subsubsection{\texttt{delores.tex}}

This is the \LaTeX{} source for this document.

\subsection{Cross-platform compatibility}

\subsubsection{\texttt{config.h}}

This file is automatically generated by the Autoconf
\texttt{configure} script distributed with DELORES; it
\texttt{\#define}s a number of C preprocessor macros informing DELORES
which C features are available on the host system.  For those systems
which for whatever reason cannot run the \texttt{configure} script,
\texttt{config.h} can be manually produced using \texttt{config.h.in}
as a template.

\subsubsection{\texttt{dl\_stdbool.h}}

DELORES makes use of C99's \texttt{bool} data type.  This data type is
not yet available on all C compilers, so \texttt{dl\_stdbool.h} is
provided as a wrapper to the official library header
\texttt{<stdbool.h>}.  If the user's compiler does not have the
\texttt{bool} data type, then \texttt{dl\_stdbool.h} will define it.
Any source file using boolean variables must \texttt{\#include
  "dl\_stdbool.h"} instead of \texttt{<stdbool.h>}.

\subsubsection{\texttt{dl\_stdint.h}}

DELORES makes extensive use of various preprocessor macros and data
types defined in the \texttt{<stdint.h>} header, which is new in C99.
Since C99 is not yet widely supported, DELORES's \texttt{dl\_stdint.h}
wrapper should be used in place of \texttt{<stdint.h>}.  Files making
use of the macros \texttt{PRIuMAX}, \texttt{SCNuMAX},
\texttt{SIZE\_MAX}; the data type \texttt{uintmax\_t}; or the function
\texttt{strtoumax()} \texttt{\#include} this wrapper.

\subsubsection{\texttt{dl\_strdup.h}, \texttt{dl\_strdup.c}}

The \texttt{strdup()} function is a non-standard extension to the C
language provided by many compilers.  For those compilers which do not
include this function, we define our own version here.  Any file which
uses the \texttt{strdup()} function should therefore be sure to
\texttt{\#include "dl\_strdup.h"}

\subsection{Memory management}

The following files were incorporated into DELORES over fears that the
native memory management provided by the development environment
and/or operating system (\textit{i.e.}, \texttt{malloc()} and friends)
would be too slow.  With this code, developers now have the option of
compiling DELORES with the default memory management scheme, or with
BGET, a public domain memory allocation package by John Walker. The
original BGET source code has been modified somewhat for smoother
integration with DELORES, to eliminate some unnecessary code and
internal documentation, and to correct \texttt{brel()}'s
incompatibility with \texttt{free()}.

\subsubsection{\texttt{dl\_malloc.h}}
  
In this header is defined the macro \texttt{DL\_USE\_BGET}, whose
presence indicates to use the BGET memory allocation package instead
of the environment's native \texttt{malloc()} and \texttt{free()}.
Note that all memory allocation in DELORES should be performed using
\texttt{balloc()} and \texttt{bfree()}, which are wrappers for the
BGET or native \texttt{malloc()} and \texttt{free()}. If BGET support
is enabled, this header also gives the prototype for
\texttt{bufferPoolInitialize()}, which must be called before the first
use of \texttt{balloc()}. The \texttt{dl\_malloc.h} file should be
included in any file making use of dynamic memory allocation.

\subsubsection{\texttt{dl\_malloc.c}}
  
This file defines the function \texttt{balloc()}, which is essentially
a wrapper for either \texttt{malloc()} or BGET's \texttt{bget()},
depending on whether or not the \texttt{DL\_USE\_BGET} macro is
defined. \texttt{balloc()} has the added functionality of checking the
return value of the memory allocation function, and aborting execution
if no further memory is available.  If \texttt{DL\_USE\_BGET} is
defined, this file also includes code for the
\texttt{bufferPoolInitialize()} function and the two static functions
it calls.
  
\subsubsection{\texttt{bget.h}}
  
This is the header file for the BGET memory allocator. It includes
prototypes for functions (which are not used outside \texttt{bget.c}
and \texttt{dl\_malloc.*}) and some useful macros and a typedef. (For
some reason, the author of BGET elected to use \texttt{long} instead
of the standard \texttt{size\_t} for his memory buffers; accordingly,
BGET is not completely compatible with \texttt{malloc()} and
friends.\footnote{This may explain why DELORES compiled with BGET
  periodically crashes on some systems.})  There is no need to include
this file as it is already included in the \texttt{dl\_malloc} files.
  
\subsubsection{\texttt{bget.c}}
  
This file contains the code for BGET, John Walker's memory allocation
package which serves as a faster, mostly-compatible replacement for
\texttt{malloc()}. Some of the code in \texttt{bget.c}, and its
associated header \texttt{bget.h}, has been modified by the DELORES author.


\subsection{Hash table abstract data type}

The hash table data type comes in a separate module, OHASH, comprising
the two files \texttt{ohash.h} and \texttt{ohash.c}. OHASH is a public
domain hash table module by Tristan Miller, based on public domain
code by Jerry Coffin.  OHASH comes with extensive internal
documentation, and the reader is encouraged to consult it.

\subsubsection{\texttt{ohash.h}}
  
This header gives typedefs and function prototypes for the hash table
ADT. Any DELORES source file making use of hash tables needs to
include this file.
  
\subsubsection{\texttt{ohash.c}}
  
This file includes the source code for the functions to add to, delete
from, and search hash tables.

\subsection{Timer abstract data type}

The timer ADTs provide an interface for creating timers to measure CPU
time and, if possible, real time. The source code is extremely simple,
usage of this module should be obvious from a cursory examination of
the header file.


\subsubsection{\texttt{timer.h}}
  
This header gives the typedefs and function prototypes dealing with
real-time and CPU-time timers. Any file making use of the
\texttt{cpuTimer} and \texttt{realTimer} data types and associated
functions should include this file.
  
\subsubsection{\texttt{timer.c}}
  
This file provides the definitions for functions which initialize,
reset, read, and destroy timers. Some of the code is
platform-specific; its inclusion is determined by preprocessor
directives in timer.h. If the platform does not support real-time
timers with subsecond resolution, then reading a \texttt{realTimer}
will always return 0.

\subsection{Command-line argument processing}

Because of the inflexibility and nonportability of \texttt{getopt()},
the command line argument processor has been manually implemented as a
Flex lexer.

\subsubsection{\texttt{cmd\_line\_args.h}}
  
This header file typedefs a struct, \texttt{cmdargs\_t}, which is used
to pass the parsed command line arguments from the lexer. It also
contains the function prototype for \texttt{getCmdLineArgs()}, the
function which does the actual processing.

\subsubsection{\texttt{cmd\_line\_args.l}}
  
This file contains the Flex lexer for processing the command-line
arguments. It is responsible for determining whether the requested
hash table sizes, \textit{etc}., are within the acceptable limits, and
also for finding the closest prime to the arguments for the
\texttt{-a} and \texttt{-r} options.

\subsubsection{\texttt{primes.txt}}
  
This text file lists the first 100\,008 primes,\footnote{Source:
  \url{http://www.utm.edu/research/primes/lists/small/}} plus a few
more. It is used to search for the smallest prime greater than or
equal to the number given with the \texttt{-a} and \texttt{-r}
command-line options.

\subsubsection{\texttt{cmd\_line\_args.c}}
  
This is the C source code produced when Flex is invoked on
\texttt{cmd\_line\_args.l}. It is an intermediate file and, provided
one has Flex, may be safely deleted after project compilation.

\subsection{Main interpreter}

\subsubsection{\texttt{dl.h}}
  
This header file contains data types, global variables, function
prototypes, and macros shared among the lexer, parser, and
interpreter.
  
\subsubsection{\texttt{lexer.l}}
  
This is the interpreter's lexer; its primary job is to recognize
tokens (keywords, atoms, variables, and labels) and pass them onto the
parser. It is also responsible for ignoring comments, and for
processing \texttt{include}d files. This file must be processed by
Flex to yield a C source file, \texttt{lexer.c}. The lexer is invoked
by the parser, \texttt{parser.y}.
  
\subsubsection{\texttt{parser.y}}
  
This file contains the interpreter's parser, which is processed by
Bison to yield the C source files \texttt{parser.h} and
\texttt{parser.c}. The parser is the main loop of the interpreter; it
is responsible for recognizing the grammar of the defeasible logic
language and deciding which functions to call.
  
\subsubsection{\texttt{dl.c}}
      
This file contains all the functions called by the parser to
manipulate the program's data. It contains the core of the
interpreter's functionality; there are functions to add and delete
literals, rules, and atoms, as well as routines for executing the
defeasible logic reasoning engines.
  
\subsubsection{\texttt{main.c}}
  
This file contains \texttt{main()} and is the point of entry to the
interpreter. \texttt{main()} is responsible for calling the command
line argument lexer and making the appropriate initializations based
on its return value, and then invoking the parser. This file also
contains the hash table variables, and the hashing functions used to
initialize them. (The hashing functions are not included in the ohash
module because it is meant to be an \emph{abstract} data type; no one
hashing function can work on all possible data so the user (in this
case, DELORES) is expected to provide their own hashing functions.)
  
\subsubsection{\texttt{lexer.c}}
  
\texttt{lexer.c} is the intermediate source file produced when Flex is
invoked on \texttt{lexer.l}. It may be safely deleted.
  
\subsubsection{\texttt{parser.h, parser.c}}
  
These are the intermediate source files produced when Bison is invoked
on \texttt{parser.y}. Provided one has Bison to rebuild them, they may
be safely deleted.
  
\subsubsection{\texttt{delores}}
  
This is the actual executable file of the DELORES interpreter.

\section{Bugs and debugging}

\subsection{Known issues}

The code for DELORES is believed to be bug-free, in the sense that it
has not (yet) been made to crash or to produce unpredictable results.
There is, however, one segment of code which is perhaps not as
intelligent as it could be made. Namely, the lexer code for the
\texttt{include} directive is written such that it interprets as a
filename everything between the first left parenthesis after the
\texttt{include} keyword and the last right parenthesis and period
before a newline.  Needless to say, this is problematic if one's
program contains a line such as the following:
\begin{verbatim}
include(program1.dl). include(program2.dl).
\end{verbatim}
In this case, DELORES aborts with an error indicating that the file
\texttt{"program1.dl). include(program2.dl"} cannot be found. To
rectify this behaviour is not a trivial feat, which is why it was not
done by the original author in the first place. Until such time as it
is fixed, users are cautioned to place their \texttt{include}
directives on lines separate from any other statements.

\subsection{Debugging tools}

There are a number of debugging facilities built into DELORES and its
associated modules. Typically, these facilities take the form of
conditional compilation directives which, when certain macros are
defined, compile in extra debugging information which will be printed
to standard error when the interpreter is run.

\subsubsection{Lexer}

The lexer (that part of the interpreter which recognizes individual
tokens) can be made to print out information on tokens as it
recognizes them by defining the \texttt{DL\_LEXER\_DEBUG} macro. This
macro can be found, commented out, in \texttt{dl.h}.

\subsubsection{Parser}

The parser (that part of the interpreter which recognizes the language
grammar) can be made to print out information on syntactic constructs
as it recognizes them by defining the \texttt{DL\_PARSER\_DEBUG}
macro. This macro can be found, commented out, in \texttt{dl.h}.

\subsubsection{Other functions}

To enable other helpful debugging messages in the interpreter, there
is the \texttt{DL\_DEBUG} macro, which may be enabled in
\texttt{dl.h}. When \texttt{DL\_DEBUG} is enabled, the user also has
access to the \texttt{?} command which, when appended to an atom name,
will print out detailed information on that atom. (The information
given is much more in-depth than that provided by the \texttt{print}
directive.) The \texttt{dl.h} header also includes the
\texttt{DL\_PROFILE} macro which, when enabled, will time the
execution of DELORES.  (Obviously, the results will only be meaningful
in batch mode.)

\subsubsection{BGET}

The only debugging facility in BGET is the use of \texttt{assert()}
macros, which is turned on and off with the \texttt{NDEBUG} macro.

\subsubsection{OHASH}

When compiled, OHASH looks for the presence of a
\texttt{HASH\_PROFILE} macro (commented out in \texttt{ohash.h}). If
it exists, it will compile in a special variable, \texttt{collisions},
in the hash table data structure. As its name suggests,
\texttt{collisions} holds a running total of the number of insertion
collisions for the associated hash table. Code in \texttt{main.c} will
test for the presence of the \texttt{HASH\_PROFILE} macro and, if it
exists, will print out the number of atom table and rule table
collisions before the interpreter exits. This information can be used
to test the suitability of the hashing function.

\section{Data structures}

All custom data types in DELORES (with the exception of hash tables
and timers) are defined in \texttt{dl.h}. (The reader is encouraged to
consult this file directly, as many of the concepts are mutually
referential and thus difficult to explain in prose.) There are two
fundamental data types, atoms and rules, and two aggregate data types,
rule lists and literals.

\subsection{Atoms}

Atoms are those unique, definite constants which correspond to proper
nouns in natural language. Atoms, which are C variables of type
\texttt{Atom}, are uniquely identified by a name (any sequence of
alphanumeric characters, including the underscore, which begins with a
lowercase letter) and are stored in a hash table called
\texttt{atomTable}. The \texttt{Atom} data structure contains a
pointer (\texttt{char *id}) to the atom's name; a series of boolean
variables (\texttt{bool plus\_delta}, \texttt{bool minus\_sigma\_neg},
\textit{etc}.)  giving information on what has been proved about the
atom and its negation; two pointers to a list of rules
(\texttt{RuleList *rule\_heads} and \texttt{RuleList
  *rule\_heads\_neg}) whose head is the atom or its negation; and
finally pointers (\texttt{Literal *strict\_occ}, \texttt{Literal
  *defeater\_occ\_neg}, \textit{etc}.) to lists of occurrences of that
atom (or its negation) in strict, defeasible, and defeater rule
bodies.

\subsection{Rules}

Every rule has a unique identifying label (\texttt{char *id})
comprised of alphanumeric characters and digits; the label must begin
with a letter. Labels generated by the interpreter may also contain
slashes.  Rules are C variables of type \texttt{Rule}, and are stored
in a hash table called \texttt{ruleTable}. A rule has three basic
parts: the head, the arrow type, and the body. The head is comprised
of a pointer to an atom (\texttt{Atom *head}), and a boolean flag
(\texttt{bool neg}) indicating whether the atom is to be negated. The
arrow type (\texttt{int arrow\_type}) is one of \texttt{SARROW},
\texttt{DARROW}, or \texttt{DEFARROW}; these are preprocessor macros
defined in \texttt{parser.h}. Finally, the body is a pointer to a list
of literals. Also stored with the rule is a number indicating the
order in which it was created; this is used by the \texttt{listing}
directive to sort the rules.

\subsection{Rule lists}

As the name implies, a rule list (variable of type \texttt{RuleList})
is simply a doubly-linked list of pointers to rules. Their main use is
in the \texttt{Atom} data structure; every atom \texttt{a} points to a
list of rules whose head is \texttt{a}.

\subsection{Literals}

Literals (variables of type \texttt{Literal}) are, basically speaking,
lists of atoms. They are used primarily as rule bodies. A literal
contains a pointer (\texttt{Atom *atom}) to an atom, a boolean flag
(\texttt{bool neg}) indicating whether the atom is negated, and
pointers (\texttt{Literal *next} and \texttt{Literal *prev}) to the
previous and next literals in the list. The literal will also contain
a pointer (\texttt{Rule *rule}) to the rule whose body it is in, if
applicable.  For example, take the following rule:
\begin{verbatim}
     r: h <= b1, neg b2, b3.
\end{verbatim}
This rule's body is essentially a pointer to the literal, let's call
it \texttt{L1}. Then \texttt{L1.rule} is a pointer to the rule
\textit{r}, \texttt{L1.atom} is a pointer to \textit{b1},
\texttt{L1.neg} is false, \texttt{L1.prev} is \texttt{NULL}, and
\texttt{L1.next} contains a pointer to the next literal in the body,
say, \texttt{L2}. Then \texttt{L2.rule} is a pointer to \textit{r},
\texttt{L2.atom} is a pointer to \textit{b2}, \texttt{L2.neg} is true,
and so on.

Literals also contain two more pointers, which the author has labelled
``up'' and ``down'' more for ease of visualization than for accurate
semantics. Whereas the ``prev'' and ``next'' pointers point to the
corresponding left or right literal in the rule body as it would be
written, the ``up'' and ``down'' pointers point to the previous and
next literals in that literal's \emph{equivalence class}. The
equivalence class for a literal \texttt{L} is the set of all literals
\texttt{E} for which \texttt{L.atom == E.atom} and \texttt{L.neg ==
  E.neg} and \texttt{L.rule->arrow\_type == E.rule->arrow\_type}
(where \texttt{L.rule} and \texttt{E.rule} are both
non-\texttt{NULL}). It is to these equivalence classes of literals
that the atoms' \texttt{strict\_occ}, \texttt{strict\_occ\_neg},
\textit{et al}.~pointers to point. Here is another example; assume
that these are the only two rules in the theory:
\begin{verbatim}
     r: h <= neg b1, b2.
     s: i <= neg b1.
\end{verbatim}
For simplicity's sake, assume that \texttt{b1} and \texttt{b2} are the
C variable names for the atoms $b1$ and $b2$, respectively. Further,
assume that \texttt{L1} and \texttt{L2} are \texttt{Literal} variables
for the first two body elements in $r$, and \texttt{L3} is a
\texttt{Literal} variable representing the body of $s$. Finally, say
\texttt{r} is the variable for the rule $r$, and likewise \texttt{s}
for $s$. Then we have the following:
\begin{verbatim}
     b1.strict_occ == NULL
     b1.strict_occ_neg == NULL
     b1.defeater_occ == NULL
     b1.defeater_occ_neg == NULL
     b1.defeasible_occ == NULL
     b1.defeasible_occ_neg == &L1
     b2.strict_occ == NULL
     b2.strict_occ_neg == NULL
     b2.defeater_occ == NULL
     b2.defeater_occ_neg == NULL
     b2.defeasible_occ == &L2
     L1.atom == &b1
     L1.neg == true
     L1.rule == &r
     L1.prev == NULL
     L1.next == &L2
     L1.up == NULL
     L1.down == &L3
     L2.atom == &b2
     L2.neg == false
     L2.rule == &r
     L2.prev == &L1
     L2.next == NULL
     L2.up == NULL
     L2.down == NULL
     L3.atom == &b1
     L3.neg == true
     L3.rule == &s
     L3.prev == NULL
     L3.next == NULL
     L3.up == &L1
     L3.down == NULL
\end{verbatim}

\section{Future improvements}

\subsection{Project maintenance}

\begin{itemize}
  
\item The external documentation could probably be improved,
  especially the above section on data structures, as it was produced
  under somewhat rushed conditions.

\end{itemize}

\subsection{Interpreter}

\begin{itemize}
  
\item Though the grammar is in place, the semantics for term lists,
  \texttt{faild}/\texttt{failD} declarations, and variables/grounding has yet to be
  implemented. See \texttt{lexer.l} and \texttt{parser.y} for what
  code needs to be added---sections are marked conspicuously with the
  following comments:
\begin{verbatim}
/* *** NOT IMPLEMENTED YET *** */
\end{verbatim}  
  
\item Both the syntax and semantics for \texttt{private} declarations
  has yet to be implemented.
  
\item When an error occurs interpreting a deeply-nested
  \texttt{include} file, it would be helpful to track back through the
  \texttt{include} stack much in the same way that gcc does. This
  functionality would be built into \texttt{lexer.l}.
       
\item The well-founded defeasible logic inference engine is not
  complete. Those sections which still need work are conspicuously
  marked as such in the program's internal documentation. Briefly,
  however, the only procedures which are not yet in place are the
  mechanisms for ``remembering'' the state of the rules and for
  returning the rules to that state. The former requires changes to
  \texttt{inferRevisedAlgorithm()}, and the latter changes to
  \texttt{resetRules()}, both in \texttt{dl.c}.

\end{itemize}

\appendix

\section{Copyright}

Copyright \copyright~2000 Michael Maher.\\
Copyright \copyright~2000, 2003 Tristan Miller.\\

\noindent Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

\end{document}
