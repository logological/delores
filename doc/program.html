<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>DELORES Programmer's Guide</title>
  </head>

  <body>
    <h1>DELORES Programmer's Guide</h1>

<hr>
<h2 align=center>Contents</h2>
<hr>

<dl>
<dd><a href=#introduction>Introduction</a>
    <dl>
    <dd><a href=#about>About this document</a>
    <dd><a href=#history>Program history</a>
    <dd><a href=#environment>Development environment</a>
    </dl>
<dd><a href=#overview>Overview of project files</a>
    <dl>
    <dd><a href=#makefile>Makefile</a>
    <dd><a href=#crossplatform>Cross-platform compatibility</a>
        <dl>
        <dd><a href=#odl_compile__h>dl_compile.h</a>
        <dd><a href=#odl_inline__h>dl_inline.h</a>
        <dd><a href=#odl_stdbool__h>dl_stdbool.h</a>
        <dd><a href=#odl_stdint__h>dl_stdint.h</a>
        <dd><a href=#odl_strdup__h>dl_strdup.h</a>
        <dd><a href=#otimer__h>timer.h</a>
        </dl>
    <dd><a href=#memory>Memory management</a>
        <dl>
        <dd><a href=#odl_malloc__h>dl_malloc.h</a>
        <dd><a href=#odl_malloc__c>dl_malloc.c</a>
        <dd><a href=#obget__h>bget.h</a>
        <dd><a href=#obget__c>bget.c</a>
        </dl>
    <dd><a href=#hash>Hash table abstract data type</a>
        <dl>
        <dd><a href=#oohash__h>ohash.h</a>
        <dd><a href=#oohash__c>ohash.c</a>
        </dl>
    <dd><a href=#hash>Timer abstract data type</a>
        <dl>
        <dd><a href=#otimer__h2>timer.h</a>
        <dd><a href=#otimer__c>timer.c</a>
        </dl>
    <dd><a href=#commandline>Command-line argument processing</a>
        <dl>
        <dd><a href=#ocmd_line_args__h>cmd_line_args.h</a>
        <dd><a href=#ocmd_line_args__l>cmd_line_args.l</a>
        <dd><a href=#oprimes__txt>primes.txt</a>
        <dd><a href=#ocmd_line_args__c>cmd_line_args.c</a>
        </dl>
    <dd><a href=#cgi>CGI interface</a>
        <dl>
        <dd><a href=#omakefilecgi>Makefile</a>
        <dd><a href=#ocgic__h>cgic.h</a>
        <dd><a href=#ocgic__c>cgic.c</a>
        <dd><a href=#olibcgic__a>libcgic.a</a>
        <dd><a href=#odl_cgi__c>dl_cgi.c</a>
        <dd><a href=#odl_cgi__html>dl_cgi.html</a>
        <dd><a href=#ocredits__html>credits.html</a>
        <dd><a href=#odl_cgi__cgi>dl_cgi.cgi</a>
        </dl>
    <dd><a href=#interpreter>Main interpreter</a>
        <dl>
        <dd><a href=#odl__h>dl.h</a>
        <dd><a href=#odl__l>dl.l</a>
        <dd><a href=#odl__y>dl.y</a>
        <dd><a href=#odl__c>dl.c</a>
        <dd><a href=#odl_lexyy__c>dl_lexyy.c</a>
        <dd><a href=#odl_y_tab__h>dl_y_tab.h</a>
        <dd><a href=#odl_y_tab__c>dl_y_tab.c</a>
        <dd><a href=#odl>dl</a>
        </dl>
    <dd><a href=#documentation>Documentation</a>
        <dl>
        <dd><a href=#owhats_new__txt>WHATS_NEW.txt</a>
        <dd><a href=#omanual__html>manual.html</a>
        <dd><a href=#oprogram__html>program.html</a>
        </dl>
    </dl>
<dd><a href=#bugs>Bugs and debugging</a>
    <dl>
    <dd><a href=#knownissues>Known problems</a>
    <dd><a href=#debug>Debugging tools</a>
        <dl>
        <dd><a href=#dlexer>Lexer</a>
        <dd><a href=#dparser>Parser</a>
        <dd><a href=#dother>Other functions</a>
        <dd><a href=#dbget>BGET</a>
        <dd><a href=#dohash>OHASH</a>
        <dd><a href=#dcgic>CGI interface</a>
        </dl>
    </dl>
<dd><a href=#data>Data structures</a>
    <dl>
    <dd><a href=#atoms>Atoms</a>
    <dd><a href=#rules>Rules</a>
    <dd><a href=#rulelists>Rule lists</a>
    <dd><a href=#literals>Literals</a>
    </dl>
<dd><a href=#future>Future improvements</a>
    <dl>
    <dd><a href=#imaintenance>Project maintenance</a>
    <dd><a href=#iinterface>Interface</a>
    <dd><a href=#iinterpreter>Interpreter</a>
    </dl>
<dd><a href=#credits>Credits</a>
</dl>

<a name=introduction></a>
<hr>
<h2 align=center>Introduction</h2>
<hr>

<a name=about></a><h3>About this document</h3>

<p>DELORES is a defeasible logic interpreter which works in interactive or batch mode.  The following document is intended to assist future developers and maintainers of the DELORES project in comprehending the structure of the source code.  It is not intended to cover in great detail the inner workings of the individual functions, and as such should not be considered a replacement for the program's internal documentation.</p>

<a name=history></a><h3>Program history</h3>

<p>The original DELORES was implemented from 13 October 1999 to 13 January 2000 at Griffith University by <a href="http://www.nothingisreal.com/">Tristan Miller</a>, based on instructions and papers provided by <a href="mailto:M.Maher@cit.gu.edu.au">Michael Maher</a>.</a>

<a name=environment></a><h3>Development environment</h3>

<p>DELORES was developed with Flex version 2.5.4, GNU Bison version 1.25, and gcc version egcs-2.91.66 19990314/Linux (egcs-1.1.2 release) with glibc 2.1 on an Intel Pentium II running SuSE Linux 6.2.  The author has taken considerable measures to ensure that the code is as a portable as possible across compilers and architectures.  The following quirks should be noted:</p>

<ul>

<li><p>All C code is written in as portable a dialect as possible, and indeed should compile without warnings on a strictly-conforming ANSI C89, C94, or C9X system.  However, please read the caveats discussed in <i>Cross-platform compatibility</i> below.</p>

<li><p>Due primarily the use of buffer switching in the lexers (cmd_line_args.l and dl.l), they must be processed using Flex.  The lexer source code cannot be processed with standard (AT&amp;T) lex or other variants.  However, it should be noted that the source code produced by Flex is ANCI C89 standard C.  If your system does not have Flex, or will not properly compile the Flex source code (which is public domain), simply invoke Flex on a machine that supports it and copy the resulting C source file.</p>

<li><p>Though it has not been extensively tested, the parser source code (dl.y) should be completely compatible with all known versions of yacc.  Note, however, that the Makefile is written assuming that GNU Bison will be used, and thus it uses Bison-specific switches for controlling the output file name.</p>

<li><p>The current prototype CGI interface makes use of POSIX pipes.  This limitation can be overcome by building the functionality of main.c's main() into dl_cgic.c's cgiMain(), and then recompiling DELORES with dl_cgic.o substituted for main.o.</p>

<li><p>Finally, there is an aesthetic issue which developers may wish to take note of:  all the original source files in the DELORES project assume a tab width of 4.  Please adjust your editor's settings accordingly, or use Unix's <tt>expand</tt> function before editing the files.</p>

</ul>

<a name=overview></a>
<hr>
<h2 align=center>Overview of project files</h2>
<hr>

<a name=makefile></a><h3>Makefile</h3>

<p>The Makefile should allow for compilation out-of-the-box on most Unix systems.  The Makefile is easily adapted to MS-DOS or other operating systems, since Flex and Bison are invoked with flags which guarantee they do not produce filenames which violate MS-DOS naming conventions.  Invoking the Makefile without arguments produces a standard executable suitable for debugging.  Other rules which are known to work include the following:</p>

<ul>

<li><tt>efence</tt> produces a standard executable, suitable for debugging, and links it to the efence library to catch dynamic memory bugs.  The efence package must be installed on the system to use this rule.

<li><tt>clean</tt> removes all intermediate source and object files, and any existing core file

<li><tt>bak</tt> creates a backup of the current directory in a subdirectory named <i>bak</i>, overwriting any existing <i>bak</i> subdirectory.

</ul>

<p>There are also a few other rules which probably do not work as-is.  The author is admittedly not familiar enough with Make to determine how to properly implement these rules, but they are noted here nonetheless with the hope that some future maintainer may fix them.  (The precise problem stems from the fact that the compiler switches these rules mandate need to be used when compiling all the intermediate source files, whereas the rules in their current state only invoke the compiler switches as it links the object files together.)</p>

<ul>

<li><tt>optimized</tt> should produce, as the name suggests, an optimized executable without debugging information.
<li><tt>prof</tt> should compile in the necesarry profiling information for prof or gprof
<li><tt>ansi</tt> should turn off all proprietary language extensions

</ul>

<a name=crossplatform></a><h3>Cross-platform compatibility</h3>

<p>The following files, containing mostly preprocessor directives, exist to ensure that the proper header files, typedefs, macros, etc. are included no matter what compiler or architecture is used.  Though DELORES can be compiled as strict ANSI C89 C, it does take advantage of ANSI C99 extensions (e.g. long long types) and compiler-specific extensions (e.g. subsecond-resolution clocks) where available.  At present, these preprocessor directives can recognize with certainty only whether they are being compiled with a GNU C Compiler with glibc, with a C compiler and library strictly conforming to ANSI C89, or with a C compiler and library strictly conforming to C99.  They are not guaranteed to properly recognize any other environment (though there is some attempt at divining the presence of a SunOS C library).</p>

<p>It was only after the author created all these conditional compilation headers that he learned of the existence of GNU Autoconf, a development tool which apparently takes care of such matters automatically.  Thus, the replacement of these files (which are admittedly complicated and not guaranteed to work on all development environments) with the facilities provided by Autoconf is left as a project for future maintainers of the code.</p>

<a name=odl_compile__h></a><h4>dl_compile.h</h4>
<blockquote>This file is used for setting very general compiler-specific options.  It attempts to set macros for enabling all ANSI C9X, POSIX, 4.3BSD, and SVID extensions.  (Obviously, such macros are not the same for all C libraries; the ones used here are known to work with glibc.)  Also, if the file is not compiled with the GNU C Compiler, the GNU-specific __extension__ macro is disabled.  The dl_compile.h header should be included in all DELORES files as the first header file included.</blockquote>

<a name=odl_inline__h></a><h4>dl_inline.h</h4>
<blockquote>This file attempts to divine whether the development environment supports inline functions.  The __inline__ macro is then set to the keyword appropriate to the development environment, or is left blank if inline functions are not supported.  This header file should be included in all DELORES files making use of inline functions.</blockquote>

<a name=odl_stdbool__h></a><h4>dl_stdbool.h</h4>
<blockquote>This file attempts to divine whether the development environment supports boolean variables.  If so, the standard C9X header file stdbool.h is included; if not, some appropriate typedefs and macros are created to emulate boolean variable support.  The dl_stdbool.h header should be included in all DELORES files making use of boolean variables.</blockquote>

<a name=odl_stdint__h></a><h4>dl_stdint.h</h4>
<blockquote>The dl_stdint.h header tries to determine the development environment's support for standard integer types.  Specifically, it checks for the presence of the C9X uintmax_t type and sets up macros for that type's format specifier and string conversion function.  The file also looks for the C9X macro SIZE_MAX, which defines the largest value representable in a size_t.  If neither uintmax_t nor SIZE_MAX support is found, the file provides its own versions.  Certain files which need to print or manipulate variables of type size_t should include this header.</blockquote>

<a name=odl_strdup__h></a><h4>dl_strdup.h</h4>
<blockquote>This file determines whether the nonstandard strdup() function is available and, if not, provides a prototype for its own version in dl_strdup.c.  This header should be included in any file making use of strdup().</blockquote>

<a name=otimer__h></a><h4>timer.h</h4>
<blockquote>This file tries to determine whether the development environment includes a real-time (cf. CPU-time) timer function offering subsecond resolution.It then provides prototypes for the timing functions in timer.c.  Any file making use of the cpuTimer and realTimer data types and associated functions should include this file. (See also the entry under <i>Timer abstract data type</i>.)</blockquote>

<a name=memory></a><h3>Memory management</h3>

<p>The following files were incorporated into DELORES over fears that the native memory management provided by the development environment and/or operating system (i.e. malloc() and friends) would be too slow.  With this code, developers now have the option of compiling DELORES with the default memory management scheme, or with BGET, a public domain memory allocation package by John Walker.  The original BGET source code has been modified somewhat for smoother integration with DELORES, to eliminate some unnecessary code and internal documentation, and to correct brel()'s incompatibility with free().  The original source code for BGET is provided with DELORES in the <i>bget</i> subdirectory.</p>

<a name=odl_malloc__h></a><h4>dl_malloc.h</h4>
<blockquote>In this header is defined the macro DL_USE_BGET, whose presence indicates to use the BGET memory allocation package instead of the environment's native malloc() and free().  Note that all memory allocation in DELORES should be performed using balloc() and bfree(), which are wrappers for the BGET or native malloc() and free().  If BGET support is enabled, this header also gives the prototype for bufferPoolInitialize(), which must be called before the first use of balloc().  The dl_malloc.h file should be included in any file making use of dynamic memory allocation.</blockquote>

<a name=odl_malloc__c></a><h4>dl_malloc.c</h4>
<blockquote>This file defines the function balloc(), which is essentially a wrapper for either malloc() or BGET's bget(), depending on whether or not the DL_USE_BGET macro is defined. balloc() has the added functionality of checking the return value of the memory allocation function, and aborting execution if no further memory is available.  If DL_USE_BGET is defined, this file also includes code for the bufferPoolInitialize() function and the two static functions it calls.</blockquote>

<a name=obget__h></a><h4>bget.h</h4>
<blockquote>This is the header file for the BGET memory allocator.  It includes prototypes for functions (which are not used outside bget.c and dl_malloc.*) and some useful macros and a typedef.  (For some reason, the author of BGET elected to use long instead of the standard size_t for his memory buffers; accordingly, BGET is not completely compatible with malloc() and friends.)  There is no need to include this file as it is already included in the dl_malloc files.</blockquote>

<a name=obget__c></a><h4>bget.c</h4>
<blockquote>This file contains the code for BGET, John Walker's memory allocation package which serves as a faster, mostly-compatible replacement for malloc().  Some of the code in bget.c, and its associated header bget.h, has been modified by the DELORES author.  The original BGET can be found in the <i>bget</i> subdirectory.</blockquote>

<a name=hash></a><h3>Hash table abstract data type</h3>

<p>The hash table data type comes in a separate module, OHASH, comprising the two files ohash.h and ohash.c.  OHASH is a public domain hash table module by Tristan Miller, based on public domain code by Jerry Coffin.  The source files have been modified somewhat for better integration with DELORES; the originals may be found in the <i>ohash</i> subdirectory.  OHASH comes with extensive internal documentation, and the reader is encouraged to consult it.</p>

<a name=oohash__h></a><h4>ohash.h</h4>
<blockquote>This header gives typedefs and function prototypes for the hash table ADT.  Any DELORES source file making use of hash tables needs to include this file.</blockquote>

<a name=oohash__c></a><h4>ohash.c</h4>
<blockquote>This file includes the source code for the functions to add to, delete from, and search hash tables.</blockquote>

<a name=timer></a><h3>Timer abstract data type</h3>

<p>The timer ADTs provide an interface for creating timers to measure CPU time and, if possible, real time.  The source code is extremely simple, usage of this module should be obvious from a cursory examination of the header file.</p>

<a name=otimer__h2></a><h4>timer.h</h4>
<blockquote>This header gives the typedefs and function prototypes dealing with real-time and CPU-time timers.  Any file making use of the cpuTimer and realTimer data types and associated functions should include this file. (Real-time timers are compiler-specific; see also the entry under <i>Cross-platform compatibility</i>.)</blockquote>

<a name=otimer__c></a><h4>timer.c</h4>
<blockquote>This file provides the definitions for functions which initialize, reset, read, and destroy timers.  Some of the code is platform-specific; its inclusion is determined by preprocessor directives in timer.h.  If the platform does not support real-time timers with subsecond resolution, then reading a realTimer will always return 0.</blockquote>

<a name=commandline></a><h3>Command-line argument processing</h3>

<p>Because of the inflexibility and nonportability of getopt(), the command line argument processor has been manually implemented as a Flex lexer.</p>

<a name=ocmd_line_args__h></a><h4>cmd_line_args.h</h4>
<blockquote>This header file typedefs a struct, cmdargs_t, which is used to pass the parsed command line arguments from the lexer.  It also contains the function prototype for getCmdLineArgs(), the function which does the actual processing.</blockquote>

<a name=ocmd_line_args__l></a><h4>cmd_line_args.l</h4>
<blockquote>This file contains the Flex lexer for processing the command-line arguments.  It is responsible for determining whether the requested hash table sizes, etc., are within the acceptable limits, and also for finding the closest prime to the arguments for the <tt>-a</tt> and <tt>-r</tt> options.</blockquote>

<a name=oprimes__txt></a><h4>primes.txt</h4>
<blockquote>This text file lists the first 100&nbsp;008 primes, plus a few more.  It is used to search for the smallest prime greater than or equal to the number given with the <tt>-a</tt> and <tt>-r</tt> command-line options.  (Source: <a href="http://www.utm.edu/research/primes/lists/small/">http://www.utm.edu/research/primes/lists/small/</a>)</blockquote>

<a name=ocmd_line_args__c></a><h4>cmd_line_args.c</h4>
<blockquote>This is the C source code produced when Flex is invoked on cmd_line_args.l.  It is an intermediate file and may be deleted after project compilation.</blockquote>

<a name=cgi></a><h3>CGI interface</h3>

<p>DELORES comes with a rudimentary CGI interface.  At the time of this writing, it is not state-persistent; the CGI interface is, more than anything, simply a framework for others to build upon.  The CGI interface is contained within the subdirectory <i>dl_cgi</i>, and makes use of an unmodified version of Thomas Boutell's CGIC ANSI C library.  The complete source code and documentation for CGIC, as well as debugging tools for it, can be found in the subdirectory <i>cgic106</i>.</p>

<a name=omakefilecgi></a><h4>Makefile</h4>
<blockquote>This file will compile the CGI interface on Unix systems; some minor tweaking may be necessary for other operating systems.  See the CGIC documentation for details.</blockquote>

<a name=ocgic__h></a><h4>cgic.h</h4>
<blockquote>This is the header file for the CGIC library.  It needs be included in any source file interacting with the CGI environment.</blockquote>

<a name=ocgic__c></a><h4>cgic.c</h4>
<blockquote>This is the source code for the CGIC library.  It has not been modified from the original.</blockquote>

<a name=olibcgic__a></a><h4>libcgic.a</h4>
<blockquote>This library file is produced by the Makefile.  It may be safely deleted after project compilation.</blockquote>

<a name=odl_cgi__c></a><h4>dl_cgi.c</h4>
<blockquote>This file contains the CGI interface for DELORES.  It is a very rudimentary interface which simply accepts a theory from an online HTML form, writes the data to a temporary file, and then invokes DELORES with that temporary file's name as a command-line argument.  DELORES's output is then piped to the web browser.</blockquote>

<a name=odl_cgi__html></a><h4>dl_cgi.html</h4>
<blockquote>This file contains the HTML form used to send the user's theory to the CGI interface.  The CGI interface will return this file by default when called without a theory.</blockquote>

<a name=ocredits__html></a><h4>credits.html</h4>
<blockquote>The credits.html file lists authorship and copyright information for DELORES and the CGI interface.  As well as being a courtesy to the developers, it is legally required to be accessible to users under the terms of Thomas Boutell's CGIC license.</blockquote>

<a name=odl_cgi__cgi></a><h4>dl_cgi.cgi</h4>
<blockquote>This is the executable of the CGI interface.  It should be invoked from a web browser, but can also be run from the command line if one has a CGI environment file produced by CGIC's debugging facility (capture.c).</blockquote>

<a name=interpreter></a><h3>Main interpreter</h3>

<a name=odl__h></a><h4>dl.h</h4>
<blockquote>This header file contains data types, global variables, function prototypes, and macros shared among the lexer, parser, and interpreter.</blockquote>

<a name=odl__l></a><h4>dl.l</h4>
<blockquote>This is the interpreter's lexer; its primary job is to recognize tokens (keywords, atoms, variables, and labels) and pass them onto the parser.  It is also responsible for ignoring comments, and for processing <tt>include</tt>d files.  This file must be processed by Flex to yield a C source file, dl_lexyy.c.  The lexer is invoked by the parser, dl.y.</blockquote>

<a name=odl__y></a><h4>dl.y</h4>
<blockquote>This file contains the interpreter's parser, which is processed by Bison to yield the C source files dl_y_tab.h and dl_y_tab.c.  The parser is the main loop of the interpreter; it is responsible for recognizing the grammar of the defeasible logic language and deciding which functions to call.</blockquote>

<a name=odl__c></a><h4>dl.c</h4>
<blockquote>This file contains all the functions called by the parser to manipulate the program's data.  It contains the core of the interpreter's functionality; there are functions to add and delete literals, rules, and atoms, as well as routines for executing the defeasible logic reasoning engines.</blockquote>

<a name=omain__c></a><h4>main.c</h4>
<blockquote>This file contains main() and is the point of entry to the interpreter.  main() is responsible for calling the command line argument lexer and making the appropriate initializations based on its return value, and then invoking the parser.  This file also contains the hash table variables, and the hashing functions used to initialize them.  (The hashing functions are not included in the ohash module because it is meant to be an <i>abstract</i> data type; no one hashing function can work on all possible data so the user (in this case, DELORES) is expected to provide their own hashing functions.)</blockquote>

<a name=odl_lexyy__c></a><h4>dl_lexyy.c</h4>
<blockquote>dl_lexyy.c is the intermediate source file produced when Flex is invoked on dl.l.  It may be safely deleted.</blockquote>

<a name=odl_y_tab__h></a>
<a name=odl_y_tab__c></a>
<h4>dl_y_tab.h<br>dl_y_tab.c</h4>
<blockquote>These are the intermediate source files produced when Bison is invoked on dl.y.  They may be safely deleted.</blockquote>

<a name=odl></a><h4>dl</h4>
<blockquote>This is the actual executable file of the DELORES interpreter.</blockquote>

<a name=documentation></a><h3>Documentation</h3>

<a name=owhats_new__txt></a><h4>WHATS_NEW.txt</h4>
<blockquote>This text file contains the revision history for DELORES, including a list of known bugs and a wish list.</blockquote>

<a name=omanual__html></a><h4>manual.html</h4>
<blockquote>This HTML file is the user's manual for DELORES.</blockquote>

<a name=oprogram__html></a><h4>program.html</h4>
<blockquote>This HTML file is the programmer's guide for DELORES.</blockquote>

<a name=bugs></a>
<hr>
<h2 align=center>Bugs and debugging</h2>
<hr>

<a name=knownissues></a><h3>Known issues</h3>
<p>The code for DELORES is believed to be bug-free, in the sense that it has not (yet) been made to crash or to produce unpredictable results.  There is, however, one segment of code which is perhaps not as intelligent as it could be made.  Namely, the lexer code for the <tt>include</tt> directive is written such that it interprets as a filename everything between the first left parenthesis after the <tt>include</tt> keyword and the last right parenthesis and period before a newline.  Needless to say, this is problematic if one's program contains a line such as the following:</p>

<blockquote><tt>include(program1.dl). include(program2.dl).</tt></blockquote>

<p>In this case, DELORES aborts with an error indicating that the file "program1.dl). include(program2.dl" cannot be found.  To rectify this behaviour is not a trivial feat, which is why it was not done by the original author in the first place.  Until such time as it is fixed, users are cautioned to place their <tt>include</tt> directives on lines separate from any other statements.</p>

<p>As mentioned previously, there remain some issues regarding the proper construction of the Makefile; while DELORES will compile correctly with the default options, the other Make rules may not be defined properly.  Also, the preprocessor directives (contained largely in the dl_*.h header files) are not guaranteed to recognize the capabilities of all compilers, C libraries, and operating systems; future maintainers are advised to dispense with them and use GNU Autoconf instead.  (The author himself has not used GNU Autoconf, but its use in this project is something which has been repeatedly recommended to him.)</p>

<a name=debug></a><h3>Debugging tools</h3>
<p>There are a number of debugging facilities built into DELORES and its associated modules.  Typically, these facilities take the form of conditional compilation directives which, when certain macros are defined, compile in extra debugging information which will be printed to standard error when the interpreter is run.</p>

<a name=dlexer></a><h4>Lexer</h4>
<blockquote>The lexer (that part of the interpreter which recognizes individual tokens) can be made to print out information on tokens as it recognizes them by defining the DL_LEXER_DEBUG macro.  This macro can be found, commented out, in dl.h.</blockquote>

<a name=dparser></a><h4>Parser</h4>
<blockquote>The parser (that part of the interpreter which recognizes the language grammar) can be made to print out information on syntactic constructs as it recognizes them by defining the DL_PARSER_DEBUG macro.  This macro can be found, commented out, in dl.h.</blockquote>

<a name=dother></a><h4>Other functions</h4>
<blockquote>To enable other helpful debugging messages in the interpreter, there is the DL_DEBUG macro, which may be enabled in dl.h.  When DL_DEBUG is enabled, the user also has access to the <tt>?</tt> command which, when appended to an atom name, will print out detailed information on that atom.  (The information given is much more in-depth than that provided by the <tt>print</tt> directive.)  The dl.h header also includes the DL_PROFILE macro which, when enabled, will time the execution of DELORES.  (Obviously, the results will only be meaningful in batch mode.)</blockquote>

<a name=dbget></a><h4>BGET</h4>
<blockquote>The only debugging facility in BGET is the use of assert() macros, which is turned on and off with the NDEBUG macro.</blockquote>

<a name=dohash></a><h4>OHASH</h4>
<blockquote>When compiled, OHASH looks for the presence of a HASH_PROFILE macro (commented out in ohash.h).  If it exists, it will compile in a special variable, <i>collisions</i>, in the hash table data structure.  As its name suggests, <i>collisions</i> holds a running total of the number of insertion collisions for the associated hash table.  Code in main.c will test for the presence of the HASH_PROFILE macro and, if it exists, will print out the number of atom table and rule table collisions before the interpreter exits.  This information can be used to test the suitability of the hashing function.</blockquote>

<a name=dcgic></a><h4>CGI interface</h4>
<blockquote>CGI programs are notoriously difficult to debug since they can seldom be successfully executed from a shell.  Thomas Boutell's CGIC library provides a debugging program, capture.c, which can store a CGI environment for use with debugging CGI programs such as dl_cgi.c.  Please refer to the CGIC documentation in the <i>cgic106</i> subdirectory for usage instructions.</blockquote>

<a name=data></a>
<hr>
<h2 align=center>Data structures</h2>
<hr>

<p>All custom data types in DELORES (with the exception of hash tables and timers) are defined in dl.h.  (The reader is encouraged to consult this file directly, as many of the concepts are mutually referential and thus difficult to explain in prose.)  There are two fundamental data types, atoms and rules, and two aggregate data types, rule lists and literals.</p>

<a name=atoms></a><h3>Atoms</h3>
<p>Atoms are those unique, definite constants which correspond to proper nouns in natural language.  Atoms, which are C variables of type Atom, are uniquely identified by a name (any sequence of alphanumeric characters, including the underscore, which begins with a lowercase letter) and are stored in a hash table called atomTable.  The Atom data structure contains a pointer (char *id) to the atom's name; a series of boolean variables (Bool plus_delta, Bool minus_sigma_neg, etc.) giving information on what has been proved about the atom and its negation; two pointers to a list of rules (RuleList *rule_heads and RuleList *rule_heads_neg) whose head is the atom or its negation; and finally pointers (Literal *strict_occ, Literal *defeater_occ_neg, etc.) to lists of occurrences of that atom (or its negation) in strict, defeasible, and defeater rule bodies.</p>

<a name=rules></a><h3>Rules</h3>
<p>Every rule has a unique identifying label (char *id) comprised of alphanumeric characters and digits; the label must begin with a letter.  Labels generated by the interpreter may also contain slashes.  Rules are C variables of type Rule, and are stored in a hash table called ruleTable.  A rule has three basic parts: the head, the arrow type, and the body.  The head is comprised of a pointer to an atom (Atom *head), and a boolean flag (_Bool neg) indicating whether the atom is to be negated.  The arrow type (int arrow_type) is one of SARROW, DARROW, or DEFARROW; these are preprocessor macros defined in dl_y_tab.h.  Finally, the body is a pointer to a list of literals.  Also stored with the rule is a number indicating the order in which it was created; this is used by the <tt>listing</tt> directive to sort the rules.</p>

<a name=rulelists></a><h3>Rule lists</h3>
<p>As the name implies, a rule list (variable of type RuleList) is simply a doubly-linked list of pointers to rules.  Their main use is in the Atom data structure; every atom <i>a</i> points to a list of rules whose head is <a>a</i>.</p>

<a name=literals></a><h3>Literals</h3>
<p>Literals (variables of type Literal) are, basically speaking, lists of atoms.  They are used primarily as rule bodies.  A literal contains a pointer (Atom *atom) to an atom, a boolean flag (_Bool neg) indicating whether the atom is negated, and pointers (Literal *next and Literal *prev) to the previous and next literals in the list.  The literal will also contain a pointer (Rule *rule) to the rule whose body it is in, if applicable.  For example, take the following rule:</p>

<blockquote><tt>r: h <= b1, neg b2, b3.</tt></blockquote>

<p>This rule's body is essentially a pointer to the literal, let's call it <i>L1</i>. Then <i>L1.rule</i> is a pointer to the rule r, <i>L1.atom</i> is a pointer to b1, <i>L1.neg</i> is false, <i>L1.prev</i> is NULL, and <i>L1.next</i> contains a pointer to the next literal in the body, say, <i>L2</i>.  Then <i>L2.rule</i> is a pointer to r, <i>L2.atom</i> is a pointer to b2, <i>L2.neg</i> is true, and so on.</p>

<p>Literals also contain two more pointers, which the author has labelled "up" and "down" more for ease of visualization than for accurate semantics.  Whereas the "prev" and "next" pointers point to the corresponding left or right literal in the rule body as it would be written, the "up" and "down" pointers point to the previous and next literals in that literal's <i>equivalence class</i>.  The equivalence class for a literal <i>L</i> is the set of all literals <i>E</i> for which <i>L.atom</i> == <i>E.atom</i> and <i>L.neg</i> == <i>E.neg</i> and <i>L.rule->arrow_type</i> == <i>E.rule->arrow_type</i> (where <i>L.rule</i> and <i>E.rule</i> are both non-NULL).  It is to these equivalence classes of literals that the atoms' strict_occ, strict_occ_neg, et al. pointers to point. Here is another example; assume that these are the only two rules in the theory:</p>

<blockquote><tt>r: h <= neg b1, b2.<br>s: i <= neg b1.</tt></blockquote>

<p>For simplicity's sake, assume that <i>b1</i> and <i>b2</i> are variable names for the atoms b1 and b2, respectively.  Further, assume that <i>L1</i> and <i>L2</i> are Literal variables for the first two body elements in r, and <i>L3</i> is a Literal variable representing the body of s.  Finally, say <i>r</i> is the variable for the rule r, and likewise <i>s</i> for s.  Then we have the following:</p>

<blockquote>
<i>b1.strict_occ</i> == NULL<br>
<i>b1.strict_occ_neg</i> == NULL<BR>
<i>b1.defeater_occ</i> == NULL<BR>
<i>b1.defeater_occ_neg</i> == NULL<BR>
<i>b1.defeasible_occ</i> == NULL<br>
<i>b1.defeasible_occ_neg</i> == &<i>L1</i><br>
<i>b2.strict_occ</i> == NULL<BR>
<i>b2.strict_occ_neg</i> == NULL<BR>
<i>b2.defeater_occ</i> == NULL<BR>
<i>b2.defeater_occ_neg</i> == NULL<BR>
<i>b2.defeasible_occ</i> == &<i>L2</i><br>
<i>L1.atom</i> == &<i>b1</i><br>
<i>L1.neg</i> == true<br>
<i>L1.rule</i> == &<i>r</i><br>
<i>L1.prev</i> == NULL<br>
<i>L1.next</i> == &<i>L2</i><br>
<i>L1.up</i> == NULL<BR>
<i>L1.down</i> == &<i>L3</i><br>
<i>L2.atom</i> == &<i>b2</i><br>
<i>L2.neg</i> == false<br>
<i>L2.rule</i> == &<i>r</i><br>
<i>L2.prev</i> == &<i>L1</i><br>
<i>L2.next</i> == NULL<br>
<i>L2.up</i> == NULL<BR>
<i>L2.down</i> == NULL<br>
<i>L3.atom</i> == &<i>b1</i><br>
<i>L3.neg</i> == true<br>
<i>L3.rule</i> == &<i>s</i><br>
<i>L3.prev</i> == NULL<br>
<i>L3.next</i> == NULL<br>
<i>L3.up</i> == &<i>L1</i><BR>
<i>L3.down</i> == NULL<br>
</blockquote>

<a name=future></a>
<hr>
<h2 align=center>Future improvements</h2>
<hr>

<a name=imaintenance></a><h3>Project maintenance</h3>
<ul>

<li><p>Use GNU Autoconf to make cross-platform/compiler compatibility easier.  This will require extensively changing/removing the existing preprocessor directives in dl_*.h, but will probably be well worth the effort.</p>

<li><p>Because the author is far from a Make guru, the current Makefile is perhaps not as good as it could be.  Using makemake to simplify Makefile maintenance is definitely something worth investigating.</p>

<li><p>No automatic revision control system is in place.  RCS or SCCS should probably be used if the project gets any larger.</p>

<li><p>The external documentation could probably be improved, especially the above section on data structures, as it was produced under somewhat rushed conditions.</p>

</ul>

<a name=iinterface></a><h3>Interface</h3>
<ul>

<li><p>The CGI interface is currently not state-persistent, and thus its use as an interactive interface is restricted.  This limitation can be overcome by adding a function, saveState(), which would write to disk the data structures used in the program (rules and atoms).  This can be done by simply traversing the two hash tables, atomTable and ruleTable, with a hashIterator, and saving the relevant contents to a text file.  (The hash table itself should <i>not</i> be saved, since it contains pointers specific to its program's instantiation, and because this would preclude the subsequent invocation of DELORES with different hash table sizes.)  A corresponding function, readState(), would process the saved state file.  Note that computer-generated rule names (those beginning with a slash character) cannot be read as-is, since they were devised based on the rule's memory address, which is not guaranteed to be the same the next time DELORES is invoked.  (If the original rule names were kept, there might be name clashes when the next invocation of DELORES decides to give some rule the same memory address, and hence name, of one in a past invocation.)  The solution is for readState() to rename all rules whose labels begin with a slash before inserting them into the rule hash table.</p>

<li><p>The CGI interface currently relies on POSIX pipes and temporary files to communicate with the interpreter, which is a separate program.  A more elegant way of interacting with the interpreter would be to make cgiMain() in dl_cgi.c do everything that main() in main.c needs to do.  In this manner, a CGI-only, fully self-contained version of DELORES can be compiled by substituting dl_cgi.o for main.o in the final linking stage.</p>

<li><p>Note that applicable URLs are hard-coded into dl_cgi.c.  Future developers will have to either modify the preprocessor macros to reflect the new URLs, or add functionality for dl_cgi.c to read its configuration settings from a file.</p>

<li><p>A GUI interface (possibly using RRSGUI) could be added.  Again, this would require either using pipes or building a new module to replace main.c.</p>

</ul>

<a name=iinterpreter></a><h3>Interpreter</h3>
<ul>

<li><p>Though the grammar is in place, the semantics for term lists, <tt>faild</tt>/<tt>failD</tt> declarations, and variables/grounding has yet to be implemented.  See dl.l and dl.y for what code needs to be added -- sections are marked conspicuously with <i>/* *** NOT IMPLEMENTED YET *** */</i> comments.</p>

<li><p>Both the syntax and semantics for <tt>private</tt> declarations has yet to be implemented.</p>

<li><p>When an error occurs interpreting a deeply-nested <tt>include</tt> file, it would be helpful to track back through the <tt>include</tt> stack much in the same way that gcc does.  This functionality would be built into dl.l.</p>

<li><p>The well-founded defeasible logic inference engine is not complete.  Those sections which still need work are conspicuously marked as such in the program's internal documentation.  Briefly, however, the only procedures which are not yet in place are the mechanisms for "remembering" the state of the rules and for returning the rules to that state.  The former requires changes to inferRevisedAlgorithm(), and the latter changes to resetRules(), both in dl.c.</p>

</ul>

<a name=credits></a>
<hr>
<h2 align=center>Credits</h2>
<hr>

<p>This document was written by Tristan Miller, and is
Copyright &copy; 2000 Michael Maher.</p>

<p>The DELORES program was written by Tristan Miller,
and is Copyright &copy; 1999, 2000 Michael Maher.</p>

<p>The DELORES Web Interface uses CGIC, a CGI library by Thomas Boutell:</p>

<blockquote><i>
CGIC, copyright 1996, 1997, 1998, 1999 by Thomas Boutell and
Boutell.Com, Inc.. Permission is granted to use CGIC in any 
application, commercial or noncommercial, at no cost. HOWEVER,
this copyright paragraph must appear on a "credits" page accessible 
in the public online and offline documentation of the program. 
Modified versions of the CGIC library should not be distributed without 
the attachment of a clear statement regarding the author of the 
modifications, and this notice may in no case be removed. 
Modifications may also be submitted to the author for inclusion 
in the main CGIC distribution.                                 
</i></blockquote>

<p>DELORES uses BGET,
a public domain memory allocator by John Walker.</p>

<p>DELORES uses OHASH,
a public domain hash table library by Tristan Miller.</p>


    <hr>
    <address><a href="mailto:psychonaut@nothingisreal.com">Tristan Miller</a></address>
<!-- Created: Tue Jan 11 01:28:52 EST 2000 -->
<!-- hhmts start -->
Last modified: Thu Jan 13 09:22:08 EST 2000
<!-- hhmts end -->
  </body>
</html>
